https://www.lanqiao.cn/problems/98/learning/



小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放 A 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。比如一共有 3 种蒸笼，分别能放 3、4 和 5 个包子。当顾客想买 11 个包子时，大叔就会选 2 笼 3 个的再加 1 笼 5 个的（也可能选出 1 笼 3 个的再加 2 笼 4 个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 3 种蒸笼，分别能放 4、5 和 6 个包子。而顾客想买 7 个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

### 输入描述

第一行包含一个整数 N (1≤*N*≤100)。

以下 N 行每行包含一个整数 Ai  (1≤*Ai ≤100)。

### 输出描述

一个整数代表答案。如果凑不出的数目有无限多个，输出 INF。

### 输入输出样例

#### 示例 1

> 输入

```txt
2
4
5
```

> 输出

```txt
6
```

> 样例说明

凑不出的数目包括：1, 2, 3, 6, 7, 11。

#### 示例 2

> 输入

```txt
2
4
6
```

> 输出

```txt
INF
```

> 样例说明

所有奇数都凑不出来，所以有无限多个



```cpp
#include<cstdio>
#include<cstring>

using namespace std;

const int N = 110, M = 10000;

// 凑不出的数最大是 10000 
// 如果只有两个数，根据裴蜀定理，凑不出的数的最大值为 (a - 1)(b - 1) - 1 
// 因为 a b 都是小于 100 的，所以凑不出的数的最大值为 99 * 99 - 1 < 10000 
// 如果数的个数增多，那么凑不出的情况小于等于 10000
int a[N];
bool f[N][M];

int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}

int main()
{
    int n;
    scanf("%d", &n);
    
    int d = 0;
    for(int i = 1; i <= n; ++i)
    {
        scanf("%d", &a[i]);
        d = gcd(a[i], d);
    }
    
    // 如果这些数的最大公约数不为 1，凑不出的数有无穷个
    if(d != 1) 
    {
        puts("INF");
        return 0;
    }
    
    // f[i][j] 表示从前 i 个数中选出总和是 j 的可能性
    // f[i][j]     = f[i-1][j] | f[i-1][j-a[i]] | f[i-1][j-a[i]*2] ... 
    // f[i][j-a[i] =             f[i-1][j-a[i]] | f[i-1][j-a[i]*2]..
    f[0][0] = true;
    for(int i = 1; i <= n; ++i)
        for(int j = 0; j < M; ++j)
        {
            f[i][j] = f[i - 1][j];
            if(j >= a[i]) f[i][j] |= f[i][j - a[i]];
        }
    
    int ans = 0;
    for(int i = 1; i < M; ++i) 
        if(!f[n][i]) ans++;
    printf("%d\n", ans);
    
    return 0;
}
```

