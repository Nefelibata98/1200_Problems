### [**L2-036 网红点打卡攻略**](https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059)



一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。

### 输入格式：

首先第一行给出两个正整数：网红点的个数 *N*（1<*N*≤200）和网红点之间通路的条数 *M*。随后 *M* 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 *N* 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 `0`。

再下一行给出一个正整数 *K*，是待检验的攻略的数量。随后 *K* 行，每行给出一条待检攻略，格式为：

*n* *V*1 *V*2 ⋯ *Vn*

其中 *n*(≤200) 是攻略中的网红点数，*V**i* 是路径上的网红点编号。这里假设你从家里出发，从 *V*1 开始打卡，最后从 *V**n* 回家。

### 输出格式：

在第一行输出满足要求的攻略的个数。

在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。

题目保证至少存在一个有效攻略，并且总路费不超过 109。

### 输入样例：

```in
6 13
0 5 2
6 2 2
6 0 1
3 4 2
1 5 2
2 5 1
3 1 1
4 1 2
1 6 1
6 3 2
1 2 1
4 5 3
2 0 2
7
6 5 1 4 3 6 2
6 5 2 1 6 3 4
8 6 2 1 6 3 4 5 2
3 2 1 5
6 6 1 3 4 5 2
7 6 2 1 3 4 5 2
6 5 2 1 4 3 6
```

### 输出样例：

```out
3
5 11
```

### 样例说明：

第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。

第 1 条攻略的总路费是：(0->5) 2 + (5->1) 2 + (1->4) 2 + (4->3) 2 + (3->6) 2 + (6->2) 2 + (2->0) 2 = 14；

第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 = 11，是一条更省钱的攻略；

第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 = 11，与第 5 条花费相同，但序号较大，所以不输出。



我用的是邻接表存储图。但是遍历时可以发现我们只需要检查两个点是否连通，所以可以同邻接矩阵来存储

```cpp
#include<iostream>
#include<map>
#include<cstring>

using namespace std;

multimap<pair<int, int>, int> alls;

const int N = 210, M = N * N;

int h[N], e[M], ne[M], w[M], idx;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int main()
{
    int n, m;
    cin >> n >> m;
    
    memset(h, -1, sizeof h);
    
    for(int i = 0; i < m; ++i)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }

    int q;
    cin >> q;
    
    // 所有攻略
    for(int i = 1; i <= q; ++i)
    {
        int p;
        cin >> p;
        
        bool st[N] = {0};
        int prev = 0, cur, cost = 0, flg = false;
        // 攻略网红点数量少于 n 
        if(p < n) flg = true;
        //cout << "0";
        // 攻略中的所有点
        for(int j = 0; j <= p; ++j)
        {
            if(j == p) cur = 0;
            else cin >> cur;
            
            // 多次访问同一个网红点
            if(st[cur]) flg = true;
            else st[cur] = true;
            
            if(flg) continue;
            
            int k;
            for(k = h[prev]; k != -1; k = ne[k])
            {
                int to = e[k], val = w[k];
                if(to == cur)
                {
                    //cout << "->" << to;
                    cost += val;
                    break;
                }
            }
            
            // 没有路径
            if(k == -1) flg = true;
            
            prev = cur;
        }
        //cout << endl;
        if(!flg && p == n) 
        {
            alls.insert({{cost, i}, i});
            //cout << cost << " " << i << endl;
        }
    }
    
    auto fir = alls.begin()->first;
    cout << alls.size() << endl << fir.second << " " << fir.first << endl;
    
    return 0;
}
```

