### [1856. 子数组最小乘积的最大值](https://leetcode-cn.com/contest/weekly-contest-240/problems/maximum-subarray-min-product/)

一个数组的 **最小乘积** 定义为这个数组中 **最小值** **乘以** 数组的 **和** 。

- 比方说，数组 `[3,2,5]` （最小值是 `2`）的最小乘积为 `2 * (3+2+5) = 2 * 10 = 20` 。

给你一个正整数数组 `nums` ，请你返回 `nums` 任意 **非空子数组** 的**最小乘积** 的 **最大值** 。由于答案可能很大，请你返回答案对 `109 + 7` **取余** 的结果。

请注意，最小乘积的最大值考虑的是取余操作 **之前** 的结果。题目保证最小乘积的最大值在 **不取余** 的情况下可以用 **64 位有符号整数** 保存。

**子数组** 定义为一个数组的 **连续** 部分。

 

**示例 1：**

```
输入：nums = [1,2,3,2]
输出：14
解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。
2 * (2+3+2) = 2 * 7 = 14 。
```

**示例 2：**

```
输入：nums = [2,3,3,1,2]
输出：18
解释：最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。
3 * (3+3) = 3 * 6 = 18 。
```

**示例 3：**

```
输入：nums = [3,1,5,6,4,2]
输出：60
解释：最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。
4 * (5+6+4) = 4 * 15 = 60 。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 107`



### 单调栈 + 前缀和

对于数组中每一个元素 i，我们向前向后寻找最后一个大于等于 `num[i]` 的元素位置,记为 `l` 和 `r`，则对于以 `num[i]` 为最小值的子数组的最小乘积为 `num[i] * (s[r] - s[l - 1])` , `s` 为前缀和数组



```cpp
typedef long long LL;

const int N = 100010, MOD = 1000000007;

LL s[N], h[N], l[N], r[N], q[N];

class Solution 
{
    
public:
    int maxSumMinProduct(vector<int>& nums) 
    {
        int n = nums.size();
        for(int i = 1; i <= n; ++i)
        {
            h[i] = nums[i - 1];
            s[i] = s[i - 1] + h[i];
        }
        
        h[0] = h[n + 1] = 0;
        int tt = 0;
        q[0] = 0;
        for(int i = 1; i <= n; ++i)
        {
            while(h[i] <= h[q[tt]]) tt--;
            l[i] = q[tt];
            q[++tt] = i;
        }
        
        tt = 0;
        q[0] = n + 1;
        for(int i = n; i; --i)
        {
            while(h[i] <= h[q[tt]]) tt--;
            r[i] = q[tt];
            q[++tt] = i;
        }
        
        LL res = 0;
        for(int i = 1; i <= n; ++i)
            // [l,r]的前缀计算公式 s[r] - s[l - 1]
            // r[i] 和 l[i] 表示第一个小于 h[i] 的下标，是我们不需要求和的下标
            res = max(res, h[i] * (s[r[i] - 1] - s[l[i]]));
        
        return res % MOD;
    }
};
```

