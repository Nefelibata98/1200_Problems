

#### 一 DFS 与 BFS 

- 在求解诸如 **最小步数**, **最短时间** 这类问题时一般只能使用 BFS 。
- 如果 DFS 可能会爆栈时，可以选择 BFS

#####  BFS 模板

```cpp

```

例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



##### DFS 模板

```cpp

```

例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 二 二分

#### 二分模板

```cpp

```

例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 三 前缀和 与 差分



例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 四 前缀和 树状数组 线段树

##### 树状数组模板

```cpp

```



例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



##### 线段树模板

```cpp

```



例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 五 数组模拟链表，队列

##### 模拟链表

```cpp

```

##### 模拟队列

```cpp

```



例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 六 递归与递推



例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 七 排序

##### 归并排序模板

```cpp

```

例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



##### 快速排序模板

```cpp

```

例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 八 数论

##### 辗转相除法

```cpp
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

##### 线性筛法

```cpp
using namespace std;

const int N = 10000;

int minp[N]; // i 的最小质数约束为 minp[i]  
int primes[N], cnt; // 记录所有质数
bool st[N];

// 质数线性筛法
int get_primes(int n)
{
    for(int i = 2; i < n; ++i)
    {
        if(!st[i]) 
        {
            primes[cnt++] = i;
            minp[i] = i;
        }
        for(int j = 0; primes[j] * i <= n; ++j)
        {
            int t = primes[j] * i;
            st[t] = true;
            minp[t] = primes[j];
            if(i % primes[j] == 0) break; 
        }
    }
}

int main(void)
{
    get_primes(10000);
    
    for(int i = 0; i < 20; ++i) cout << primes[i] << endl;
    
    return 0;
}
```

##### 快速幂 

```cpp
求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```



例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 九 DP 

##### 时间复杂度计算

`状态数 x 转移`



![](D:\图片\A pic\1200题\46.png)

#### 十 贪心



例题：

| 题目 | 难度 | 心得 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |



#### 十一 数组模拟数据结构模板

##### 单链表

```cpp
// 头插
void add_to_head(int x)
{
    e[nxt] = x, ne[nxt] = head, head = nxt++;
}

// 删除插入的第 k 个数
void delete_k(int k)
{
    ne[k] = ne[ne[k]];
}
// 如果 k 为 0 则是头删，直接写成
head = ne[head];

// 在插入的第 k 个数后插入 x
int insert(int k, int x)
{
    e[nxt] = x, ne[nxt] = ne[k], ne[k] = nxt++;
}
```

[AcWing 826. 单链表](https://www.acwing.com/problem/content/828/)



##### 双链表

```cpp
// 初始化
r[0] = 1, l[1] = 0;
idx = 2;

// 在第 k 号的右侧插入
void add(int k, int x)
{
    e[idx] = x;
    l[idx] = k, r[idx] = r[k];
    l[r[k]] = idx, r[k] = idx++; // 注意这两次赋值的顺序不能变
}

// 删除第 k 号 
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

// 最左侧插入
add(0, x); 

// 最右侧插入
add(l[1], x);

// 删除 k 
remove(k + 1);

// k 右侧插入
add(k + 1, x);

// k 左侧插入
add(l[k + 1], x);
```

[ AcWing 827. 双链表](https://www.acwing.com/problem/content/829/)



##### 栈

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```

[AcWing 828. 模拟栈](https://www.acwing.com/problem/content/830/)

##### 队列

```cpp
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}
```

[AcWing 829. 模拟队列](https://www.acwing.com/problem/content/831/)

##### 循环队列

```cpp
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```



##### 单调栈

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

[830. 单调栈](https://www.acwing.com/problem/content/832/)

##### 单调队列

```cpp
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

[AcWing 154. 滑动窗口](https://www.acwing.com/problem/content/156/)

##### 堆



##### 哈希



##### 邻接表



#### 十二 字符串

##### KMP

```cpp
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```

例题：

- [AcWing 831. KMP字符串](https://www.acwing.com/activity/content/problem/content/869/1/)

- [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

- [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)

- 

其他资料：

- https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/

##### Trie 树

```cpp
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

例题

- [835. Trie字符串统计]()



#### 注意

##### cin cout 优化

```cpp
cin.tie(0);
ios::sync_with_stdio(false);
```

