## 3/25 总结

#### 1. 应用哨兵

链表中，如果需要 一个指针指向的结点 始终在 另一个指针指向的结点 后面，而两个指针不好处理第一个结点，可以考虑创建一个哨兵结点作为表头。也就是说：

```java
//假设函数传入的头结点是 pHead
ListNode head = new ListNode(-1);
head.next = pHead;
ListNode prev = head;
ListNode cur = pHead;
// 这样 prev 就在 cur 之前了
```

通过上面的方式，也许可以让问题变的简单。

同样的，第 0001 题也说明了哨兵对程序的优化。

如果不使用哨兵，在删除链表时，对表头的删除和其他元素不太一样，因为表头没有前面一个结点，所以需要分成两种情况进行讨论。如果使用了哨兵，那所有结点就都“一视同仁”了。

#### 2. 快慢指针

0003 题，0004 题 

快慢指针极大程度的降低了程序的复杂性，提高了程序的可读性。

#### 3. 迭代思想

这体现在 0002 题。

这道题绝对是**相当经典**了，强烈推荐！当然迭代还可以在很多地方使用，比如之前我们学的斐波那契数列和求两数最大公因数的辗转辗除法。