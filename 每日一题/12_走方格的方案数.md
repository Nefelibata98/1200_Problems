## 题目描述

请计算n*m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。

本题含有多组样例输入。

## 输入描述:

```
每组样例输入两个正整数n和m，用空格隔开。(1≤n,m≤8)
```

## 输出描述:

```
每组样例输出一行结果
```

示例1

## 输入

```
2 2
1 2
```

## 输出

```
6
3
```



题解：

```
| 1 | 2 | 3 |
-------------
| 4 | 5 | 6 |
-------------
| 7 | 8 | 9 |
-------------
1. 对于上面的n*m(3*3)的格子，有两种情况
a. 如果n或者m为1，则只有一行或者一列，从左上角走到右下角的路径数为n + m
比如： 1 * 1格子，可以先向下走，再向右走，到达右下角；或者先向右走，
再向下走，到达右下角，共两条，即 1 + 1 = 2，对于1 * m和 n * m的
情况同学们自己画一下
b. 如果n,m都大于1，那么走到[n][m]格子的右下角只有两条路径，
<1>: 从[n - 1][m]格子的右下角向下走，到达
<2>: 从[n][m - 1]格子的右下角向右走，到达
所以走到[n][m]格子的右下角的数量为[n-1][m] + [n][m - 1],可以通过递归实现，情况a为递归的终止条
件。
```



```cpp
#include<iostream>
using namespace std;

int PathNum(int col, int row)
{
    // 没有格子可走
    if(!col || !row)
        return 0;
    // 路径条数为 col + row
    if(col == 1 || row == 1)
        return col + row;
    // 有向下走和向右走两种方式
    else 
        return PathNum(col - 1, row) + PathNum(col, row - 1);
}

int main(void)
{
    int col, row;
    while(cin >> col >> row)
    {
        cout << PathNum(col,row) << endl;
    }
    
    return 0;
}
```

